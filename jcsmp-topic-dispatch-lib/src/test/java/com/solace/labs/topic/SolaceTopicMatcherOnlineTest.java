/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package com.solace.labs.topic;

import static org.junit.Assert.assertTrue;

import java.util.HashSet;
import java.util.Set;

import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.Test;

import com.solace.labs.topic.TopicUtils;
import com.solacesystems.jcsmp.BytesXMLMessage;
import com.solacesystems.jcsmp.JCSMPException;
import com.solacesystems.jcsmp.JCSMPFactory;
import com.solacesystems.jcsmp.JCSMPProperties;
import com.solacesystems.jcsmp.JCSMPSession;
import com.solacesystems.jcsmp.JCSMPStreamingPublishCorrelatingEventHandler;
import com.solacesystems.jcsmp.TextMessage;
import com.solacesystems.jcsmp.XMLMessageConsumer;
import com.solacesystems.jcsmp.XMLMessageListener;
import com.solacesystems.jcsmp.XMLMessageProducer;






public class SolaceTopicMatcherOnlineTest {
	
    static JCSMPSession session = null;
    static XMLMessageProducer producer = null;
    static XMLMessageConsumer consumer = null;
    
	static Set<String> validSubs = new HashSet<>();
	static Set<String> topics = new HashSet<>();

	
	
	@BeforeClass
	public static void connectToSolace() throws JCSMPException {
		JCSMPProperties properties = new JCSMPProperties();
        properties.setProperty(JCSMPProperties.HOST, "localhost");          // host:port
        properties.setProperty(JCSMPProperties.VPN_NAME, "default");     // message-vpn
        properties.setProperty(JCSMPProperties.USERNAME, "asdf");      // client-username
//        if (args.length > 3) properties.setProperty(JCSMPProperties.PASSWORD, args[3]);  // client-password (sometimes optional)
        session = JCSMPFactory.onlyInstance().createSession(properties);
		producer = session.getMessageProducer(new JCSMPStreamingPublishCorrelatingEventHandler() {
			@Override
			public void handleErrorEx(Object arg0, JCSMPException arg1, long arg2) {
			}

			@Override
			public void responseReceivedEx(Object arg0) {
			}
		});
		consumer = session.getMessageConsumer((XMLMessageListener)null);  // blocking consumer!
		consumer.start();
        
		for (int i=0; i<1000; i++) {
			String sub = TestDataGeneratorUtil.buildRandomSub(20);
			if (TopicUtils.validateSubLinear(sub)) validSubs.add(sub);
		}
		System.out.println(validSubs.size() + " subs");
		for (int i=0; i<1000; i++) {
//			String topic = TestDataGeneratorUtil.buildRandomTopic(50);
//			if (!topic.startsWith("/") && !topic.endsWith("/") && !topic.contains("//")) topics.add(topic);
			topics.add(TestDataGeneratorUtil.buildRandomTopic(50));
		}
		TestDataGeneratorUtil.trimMalformedTopics(topics);
		System.out.println(topics.size() + " topics");
	}

	
	@AfterClass
	public static void disconnectFromSolace() {
		session.closeSession();
	}
	
	
	
    @Test
    public void testSomeLibraryMethod() throws JCSMPException {
		BytesXMLMessage msg;  // preallocate and reuse
    	for (String sub : validSubs) {
    		session.addSubscription(JCSMPFactory.onlyInstance().createTopic(sub));  // blocking add
    		Set<String> matchedTopics = new HashSet<>();
    		msg = JCSMPFactory.onlyInstance().createMessage(TextMessage.class);  // reuse the message
    		for (String topic : topics) {
    			producer.send(msg, JCSMPFactory.onlyInstance().createTopic(topic));
    			if (TopicUtils.topicMatches(topic, sub)) matchedTopics.add(topic);
    		}
    		Set<String> solaceMatches = new HashSet<>();
    		while ((msg = consumer.receive(100)) != null) {  // receive until you don't
    			solaceMatches.add(msg.getDestination().getName());
    		}
    		if (!matchedTopics.equals(solaceMatches)) {
    			System.out.println(sub);
    			System.out.println(matchedTopics);
    			System.out.println(solaceMatches);
    	    	assertTrue("test failed", false);
    		} else {
    			System.out.println("Sub: " + sub + ", matches = " + matchedTopics.size());
    		}
    		session.removeSubscription(JCSMPFactory.onlyInstance().createTopic(sub));  // blocking remove
    	}
    	assertTrue("this is true", true);
    }
}
